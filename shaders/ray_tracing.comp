#version 450

struct Sphere 
{
    vec3 Position;
    float Radius;
    uint MaterialIndex;
};

struct Plane 
{
    vec3 Position;
    vec3 Normal;
    vec3 Tangent;
    vec3 Bitangent;
    float Width;
    float Height;
    uint MaterialIndex;
};

struct Material
{
    vec3 Color;
    float Roughness;
    float Metallic;
    float Specular;
    float EmissionPower;
};

struct Ray 
{
    vec3 Origin;
    vec3 Direction;
};

struct HitPayload
{
    float HitDistance;
    vec3 WorldPosition;
    vec3 WorldNormal;
    uint ObjectIndex;
    uint ObjectType; // 0 = sphere, 1 = plane
};

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(binding = 0, rgba16f) writeonly uniform image2D HDRImage;
layout(binding = 1, rgba32f) uniform image2D AccumulationImage;


layout(std140, binding = 2) uniform UniformBufferData 
{
    vec3 CameraPosition;
    vec3 CameraFrontVector;
    vec3 CameraUpVector;
    vec3 CameraRightVector;
    float AspectRatio;
    float FieldOfView;
    uint SampleCount;
    uint MaxBounces;
    vec3 BackgroundColor;
    uint Width;
    uint Height;
    bool AccumulationEnabled;
} ubo;

layout(std430, binding = 3) buffer SphereBuffer 
{
    Sphere[] Spheres;
};

layout(std430, binding = 4) buffer PlaneBuffer
{
    Plane[] Planes;
};

layout(std430, binding = 5) buffer MaterialBuffer 
{
    Material[] Materials;
};

const float PI = 3.14159265359;
const float EPSILON = 0.01;

uint PcgHash(uint inpt) 
{
    uint state = inpt * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}

float RandomFloat(inout uint seed) 
{
    seed = PcgHash(seed);
    return float(seed) / float(0xFFFFFFFFu);
}

float RandomFloat(inout uint seed, float minVal, float maxVal) 
{
    seed = PcgHash(seed);
    float normalized = float(seed) / float(0xFFFFFFFFu);
    return minVal + normalized * (maxVal - minVal);
}

vec3 RandomInUnitSphere(inout uint seed)
{
    float z = RandomFloat(seed) * 2.0 - 1.0;
    float a = RandomFloat(seed) * 2.0 * PI;
    float r = sqrt(1.0 - z * z);
    float x = r * cos(a);
    float y = r * sin(a);
    return vec3(x, y, z);
}

vec3 CosineWeightedHemisphere(vec3 normal, inout uint seed) 
{
    float r1 = RandomFloat(seed);
    float r2 = RandomFloat(seed);

    float cosTheta = sqrt(r1);
    float sinTheta = sqrt(1.0 - r1);
    float phi = 2.0 * PI * r2;

    vec3 w = normal;
    vec3 u = normalize(cross(abs(w.x) > 0.1 ? vec3(0,1,0) : vec3(1,0,0), w));
    vec3 v = cross(w, u);

    return normalize(cosTheta * w + sinTheta * cos(phi) * u + sinTheta * sin(phi) * v);
}

vec3 SampleGGX(vec3 normal, float roughness, inout uint seed)
{
    float r1 = RandomFloat(seed);
    float r2 = RandomFloat(seed);
    
    float a = roughness * roughness;
    float a2 = a * a;
    
    float phi = 2.0 * PI * r1;
    float cosTheta = sqrt((1.0 - r2) / (1.0 + (a2 - 1.0) * r2));
    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
    
    vec3 h;
    h.x = sinTheta * cos(phi);
    h.y = sinTheta * sin(phi);
    h.z = cosTheta;
    
    vec3 up = abs(normal.z) < 0.999 ? vec3(0, 0, 1) : vec3(1, 0, 0);
    vec3 tangent = normalize(cross(up, normal));
    vec3 bitangent = cross(normal, tangent);
    
    return normalize(tangent * h.x + bitangent * h.y + normal * h.z);
}

float FresnelSchlick(float cosTheta, float F0)
{
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

vec3 FresnelSchlickVec3(float cosTheta, vec3 F0)
{
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

bool RaySphereIntersection(Ray ray, Sphere sphere, out vec3 outHitNear, out vec3 outHitFar) 
{
   vec3 oc = ray.Origin - sphere.Position;

	float a = dot(ray.Direction, ray.Direction);
	float b = 2.0 * dot(oc, ray.Direction);
	float c = dot(oc, oc) - sphere.Radius * sphere.Radius;

	float discriminant = b * b - 4.0 * a * c;

	if (discriminant >= 0.0)
	{
		float t1 = (-b - sqrt(discriminant)) / (2.0 * a);
		float t2 = (-b + sqrt(discriminant)) / (2.0 * a);

        outHitNear = ray.Origin + ray.Direction * t1;
		outHitFar = ray.Origin + ray.Direction * t2;

		return true;
	}

	return false;
}

bool RayPlaneIntersection(Ray ray, Plane plane, out vec3 outHitNear)
{
    float denom = dot(plane.Normal, ray.Direction);
    if(abs(denom) < EPSILON)
        return false;
    
    float t = dot(plane.Position - ray.Origin, plane.Normal) / denom;
    if(t < EPSILON)
        return false;
    
    vec3 hitPoint = ray.Origin + ray.Direction * t;
    
    vec3 localPoint = hitPoint - plane.Position;
    float u = dot(localPoint, plane.Tangent);
    float v = dot(localPoint, plane.Bitangent);
    
    if(abs(u) > plane.Width * 0.5 || abs(v) > plane.Height * 0.5)
        return false;
    
    outHitNear = hitPoint;
    return true;
}

HitPayload Miss(Ray ray)
{
    HitPayload hit;
    hit.HitDistance = -1.0;
    hit.ObjectType = 0xFFFFFFFFu;

    return hit;
}

HitPayload ClosestHit(Ray ray, float hitDistance, uint objectIndex, uint objectType)
{
    HitPayload hit;

	hit.HitDistance = hitDistance;
	hit.ObjectIndex = objectIndex;
    hit.ObjectType = objectType;
	hit.WorldPosition = ray.Origin + ray.Direction * hitDistance;

    if(objectType == 0u) // Sphere
        hit.WorldNormal = normalize(hit.WorldPosition - Spheres[objectIndex].Position);
    else if(objectType == 1u) // Plane
        hit.WorldNormal = Planes[objectIndex].Normal;

	return hit;
}

HitPayload TraceRay(const Ray ray)
{
    uint closestObjectIndex = 0xFFFFFFFFu;
    uint closestObjectType = 0xFFFFFFFFu;
    float closestDistance = 1e20f;
    vec3 hitNear, hitFar;

    for(uint i = 0; i < Spheres.length(); i++)
    {
        if(RaySphereIntersection(ray, Spheres[i], hitNear, hitFar))
        {
            const float distanceToNear = dot(hitNear - ray.Origin, ray.Direction);
			const float distanceToFar = dot(hitFar - ray.Origin, ray.Direction);
            float hitDistance = distanceToNear;

            if(distanceToNear < EPSILON)
            {
                hitDistance = distanceToFar;
            }
        
            if(hitDistance > EPSILON && hitDistance < closestDistance)
            {
                closestObjectIndex = i;
                closestObjectType = 0u; // sphere
                closestDistance = hitDistance;
            }
        }
    }

    for(uint i = 0; i < Planes.length(); i++)
    {
        if(RayPlaneIntersection(ray, Planes[i], hitNear))
        {
            const float hitDistance = dot(hitNear - ray.Origin, ray.Direction);

            if(hitDistance > EPSILON && hitDistance < closestDistance)
            {
                closestObjectIndex = i;
                closestObjectType = 1u; // plane
                closestDistance = hitDistance;
            }
        }
     }

    if(closestObjectIndex < 0xFFFFFFFFu)
    {
        return ClosestHit(ray, closestDistance, closestObjectIndex, closestObjectType);
    }

    return Miss(ray);
}


vec4 RayGen(vec2 coord, uint sampleCount)
{
    const float scalar = tan(radians(ubo.FieldOfView) / 2);

    vec3 totalLight = vec3(0.0);

    uint seed = uint((coord.x * 1000000.0) + (coord.y * 1000000.0) + 
                     ubo.Width + sampleCount * 982451653u);

    const uint raysPerPixel = 4;

    for(uint rayNum = 0; rayNum < raysPerPixel; rayNum++)
    {
        vec2 jitter = vec2(RandomFloat(seed), RandomFloat(seed)) - 0.5;
        vec2 jitteredCoord = coord + jitter / vec2(ubo.Width, ubo.Height);

        vec3 rayDirection = vec3(
            jitteredCoord.x * ubo.AspectRatio * scalar,
            jitteredCoord.y * scalar,
            -1.0);

        rayDirection = normalize(rayDirection.x * ubo.CameraRightVector + 
                                rayDirection.y * ubo.CameraUpVector + 
                                rayDirection.z * ubo.CameraFrontVector);
        
        Ray ray;
        ray.Origin = ubo.CameraPosition;
        ray.Direction = rayDirection;

        vec3 light = vec3(0.0);
        vec3 throughput = vec3(1.0);

        for(uint i = 0; i < ubo.MaxBounces; i++)
        {
            seed += i;

            const HitPayload hit = TraceRay(ray);

            if(hit.HitDistance >= EPSILON)
            {
                uint materialIndex = (hit.ObjectType == 0u) ? 
                                      Spheres[hit.ObjectIndex].MaterialIndex : 
                                      Planes[hit.ObjectIndex].MaterialIndex;

                const Material material = Materials[materialIndex];

                light += (material.Color * material.EmissionPower) * throughput;

                if(material.EmissionPower > 0.0)
                    break;

                vec3 normal = hit.WorldNormal;
                vec3 viewDir = -ray.Direction;

                vec3 f0 = mix(vec3(material.Specular), material.Color, material.Metallic);

                float cosTheta = max(dot(normal, viewDir), 0.0);
                float fresnel = FresnelSchlick(cosTheta, material.Specular);

                float specularChance = mix(fresnel, 1.0, material.Metallic);

                bool isSpecular = bool(RandomFloat(seed) < specularChance);

                vec3 newDirection;

                if(isSpecular)
                {
                    vec3 halfVector = SampleGGX(normal, material.Roughness, seed);
                    newDirection = reflect(-viewDir, halfVector);

                    if(dot(newDirection, normal) <= 0.0)
                    {
                        newDirection = CosineWeightedHemisphere(normal, seed);
                        isSpecular = false;
                    }
                }
                else 
                {
                    newDirection = CosineWeightedHemisphere(normal, seed);
                }

                if(isSpecular)
                {
                    vec3 h = normalize(viewDir + newDirection);
                    float voh = max(dot(viewDir, h), 0.0);
                    vec3 f = FresnelSchlickVec3(voh, f0);

                    throughput *= f / max(specularChance, 0.001);
                }
                else 
                {
                    vec3 diffuseColor = material.Color * (1.0 - material.Metallic);
                    throughput *= diffuseColor / max(1.0 - specularChance, 0.001);
                }


                ray.Origin = hit.WorldPosition + normal * EPSILON;
                ray.Direction = normalize(newDirection);
            }
            else
            {
                light += ubo.BackgroundColor * throughput;
                break;
            }
        }
        totalLight += light;
    }

   return vec4(totalLight / float(raysPerPixel), 1.0);
}


void main() 
{
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    vec2 imageSize = vec2(imageSize(HDRImage));
    vec2 coord = (vec2(pixelCoord) / imageSize) * 2.0 - 1.0;
    coord.y = -coord.y;

    vec4 color = RayGen(coord, ubo.SampleCount);

    if(ubo.AccumulationEnabled)
    {
        vec4 currentAccum = imageLoad(AccumulationImage, pixelCoord);
        vec4 newAccum = currentAccum + color;
        imageStore(AccumulationImage, pixelCoord, newAccum);

        vec4 avg = newAccum / float(ubo.SampleCount);
        imageStore(HDRImage, pixelCoord, avg);
    }
    else 
    {
        imageStore(HDRImage, pixelCoord, color);
    }
}