#version 450

struct Sphere 
{
    vec3 Position;
    float Radius;
    uint MaterialIndex;
};

struct Material
{
    vec3 Color;
    float Roughness;
    float Metallic;
    float EmissionPower;
    vec3 EmissionColor;
};

struct Ray 
{
    vec3 Origin;
    vec3 Direction;
};

struct HitPayload
{
    float HitDistance;
    vec3 WorldPosition;
    vec3 WorldNormal;
    uint ObjectIndex;
};

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(binding = 0, rgba8) writeonly uniform image2D OutputImage;
layout(binding = 1, rgba32f) uniform image2D AccumulationImage;

layout(std140, binding = 2) uniform UniformBufferData 
{
    vec3 CameraPosition;
    vec3 CameraFrontVector;
    vec3 CameraUpVector;
    vec3 CameraRightVector;
    float AspectRatio;
    float FieldOfView;
    uint SampleCount;
    uint MaxBounces;
    vec3 BackgroundColor;
    uint Width;
    uint Height;
    bool AccumulationEnabled;
} ubo;

layout(std430, binding = 3) buffer SphereBuffer 
{
    Sphere[] Spheres;
};

layout(std430, binding = 4) buffer MaterialBuffer 
{
    Material[] Materials;
};


const float PI = 3.14159265359;
const float EPSILON = 0.0001;

uint pcgHash(uint inpt) 
{
    uint state = inpt * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}

float randomFloat(inout uint seed) 
{
    seed = pcgHash(seed);
    return float(seed) / float(0xFFFFFFFFu);
}

vec3 cosineWeightedHemisphere(vec3 normal, inout uint seed) 
{
    float r1 = randomFloat(seed);
    float r2 = randomFloat(seed);

    float cosTheta = sqrt(r1);
    float sinTheta = sqrt(1.0 - r1);
    float phi = 2.0 * PI * r2;

    vec3 w = normal;
    vec3 u = normalize(cross(abs(w.x) > 0.1 ? vec3(0,1,0) : vec3(1,0,0), w));
    vec3 v = cross(w, u);

    return normalize(cosTheta * w + sinTheta * cos(phi) * u + sinTheta * sin(phi) * v);
}

bool IntersectSphere(Ray ray, Sphere sphere, out vec3 outHitNear, out vec3 outHitFar) 
{
   vec3 oc = ray.Origin - sphere.Position;

	float a = dot(ray.Direction, ray.Direction);
	float b = 2.f * dot(oc, ray.Direction);
	float c = dot(oc, oc) - sphere.Radius * sphere.Radius;

	float discriminant = b * b - 4.f * a * c;

	if (discriminant >= 0.f)
	{
		float t1 = (-b - sqrt(discriminant)) / (2 * a);
		float t2 = (-b + sqrt(discriminant)) / (2 * a);

        outHitNear = ray.Origin + ray.Direction * t1;
		outHitFar = ray.Origin + ray.Direction * t2;

		return true;
	}

	return false;
}

HitPayload Miss(Ray ray)
{
    HitPayload hit;
    hit.HitDistance = -1.0;

    return hit;
}

HitPayload ClosestHit(Ray ray, float hitDistance, uint objectIndex)
{
    HitPayload hit;

	hit.HitDistance = hitDistance;
	hit.ObjectIndex = objectIndex;
	hit.WorldPosition = ray.Origin + ray.Direction * hitDistance;
	hit.WorldNormal = normalize(hit.WorldPosition - Spheres[objectIndex].Position);

	return hit;
}

HitPayload TraceRay(const Ray ray)
{
    uint closestSphereIndex = 0xFFFFFFFFu;
    float closestDistance = 1e20f;

    vec3 hitNear, hitFar;

    for(uint i = 0; i < Spheres.length(); i++)
    {
        if(IntersectSphere(ray, Spheres[i], hitNear, hitFar))
        {
            const float distanceToNear = dot(hitNear - ray.Origin, ray.Direction);
			const float distanceToFar = dot(hitFar - ray.Origin, ray.Direction);


            if(distanceToNear > 0.0 && distanceToNear < closestDistance)
            {
                closestSphereIndex = i;
                closestDistance = distanceToNear;
            }
            else if(distanceToFar > 0.0 && distanceToFar < closestDistance)
            {
                closestSphereIndex = i;
                closestDistance = distanceToFar;
            }
        }
    }

    if(closestSphereIndex < 0xFFFFFFFFu)
    {
        return ClosestHit(ray, closestDistance, closestSphereIndex);
    }

    return Miss(ray);
}


vec4 RayGen(vec2 coord, uint sampleCount)
{
    const float scalar = tan(radians(ubo.FieldOfView) / 2);
    vec3 rayDirection = vec3(
    coord.x * ubo.AspectRatio * scalar,
    coord.y * scalar,
    -1.0);

    rayDirection = normalize(rayDirection.x * ubo.CameraRightVector + 
    rayDirection.y * ubo.CameraUpVector + 
    rayDirection.z * ubo.CameraFrontVector);

    Ray ray;
    ray.Origin = ubo.CameraPosition;
    ray.Direction = rayDirection;
    vec3 light = vec3(0.0);
    vec3 throughput = vec3(1.0);

    uint seed = uint((coord.x * 1000000.0) + (coord.y * 1000000.0) + 
                     ubo.Width + sampleCount * 982451653u);

    for(uint i = 0; i < ubo.MaxBounces; i++)
    {
        const HitPayload hit = TraceRay(ray);

        if(hit.HitDistance > 0.0)
        {
            const Material material = Materials[Spheres[hit.ObjectIndex].MaterialIndex];

            light += material.EmissionColor * material.EmissionPower;
            
            throughput *= material.Color;

            ray.Origin = hit.WorldPosition + hit.WorldNormal * EPSILON;
            ray.Direction = cosineWeightedHemisphere(hit.WorldNormal, seed);
        }
        else
        {
            //light += ubo.BackgroundColor * throughput;
            break;
        }
    }

   return vec4(light, 1.0);
}


void main() 
{
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    vec2 imageSize = vec2(imageSize(OutputImage));
    vec2 coord = (vec2(pixelCoord) / imageSize) * 2.0 - 1.0;
    coord.y = -coord.y;

    vec4 color = RayGen(coord, ubo.SampleCount);
    color = clamp(color, vec4(0.0), vec4(1.0));

    if(ubo.AccumulationEnabled)
    {
        vec4 currentAccum = imageLoad(AccumulationImage, pixelCoord);
        vec4 newAccum = currentAccum + color;
        imageStore(AccumulationImage, pixelCoord, newAccum);

        vec4 avg = newAccum / float(ubo.SampleCount);
        imageStore(OutputImage, pixelCoord, avg);
    }
    else 
    {
        imageStore(OutputImage, pixelCoord, color);
    }
}